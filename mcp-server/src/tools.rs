//! MCP Tools implementation with decorator pattern support
use crate::protocol::{Tool, ToolInput, ToolResult, ToolStatus};
use crate::error::McpResult;
use std::collections::HashMap;
use async_trait::async_trait;
use uuid::Uuid;
use serde_json::Value;

/// Trait for MCP tool implementations (auto-generated by #[mcp_tool] macro)
pub trait McpToolImpl: Send + Sync {
    /// Get tool name
    fn tool_name() -> &'static str;
    
    /// Get tool description
    fn tool_description() -> &'static str;
    
    /// Get tool category
    fn tool_category() -> &'static str;
    
    /// Get required permission (if any)
    fn requires_permission() -> Option<&'static str>;
    
    /// Check if tool is sensitive (should be excluded from public LLM access)
    fn is_sensitive() -> bool;
}

/// Enhanced MCP tool with auth and Zanzibar context
#[async_trait]
pub trait McpTool: Send + Sync {
    /// Get tool name
    fn name(&self) -> &str;
    
    /// Get tool description
    fn description(&self) -> &str;
    
    /// Get tool category
    fn category(&self) -> &str;
    
    /// Get input schema (JSON Schema)
    fn input_schema(&self) -> serde_json::Value;
    
    /// Get output schema (JSON Schema for response)
    fn output_schema(&self) -> Option<serde_json::Value>;
    
    /// Get expected render type
    fn render_type(&self) -> Option<crate::protocol::RenderType>;
    
    /// Get response type name (e.g., "Patient", "Vec<Pharmacy>")
    fn response_type_name(&self) -> Option<&str>;
    
    /// Get required permission for this tool
    fn required_permission(&self) -> Option<&str>;
    
    /// Check if tool is sensitive
    fn is_sensitive(&self) -> bool;
    
    /// Get handler function name (for registration)
    fn handler_function(&self) -> &str;
    
    /// Get handler file path (for registration)
    fn handler_file(&self) -> &str;
    
    /// Execute the tool with auth and Zanzibar context
    async fn execute(
        &self,
        input: ToolInput,
        auth_context: &AuthContext,
        zanzibar_client: Option<&dyn ZanzibarClient>,
    ) -> McpResult<ToolResult>;
}

/// Authentication context for MCP tool execution
#[derive(Debug, Clone)]
pub struct AuthContext {
    pub user_id: Uuid,
    pub organization_id: Uuid,
    pub roles: Vec<String>,
    pub permissions: Vec<String>,
    pub email: Option<String>,
}

/// Zanzibar client trait for permission checks
#[async_trait]
pub trait ZanzibarClient: Send + Sync {
    /// Check if user has permission
    async fn check_permission(
        &self,
        user_id: Uuid,
        resource_type: &str,
        resource_id: Option<Uuid>,
        permission: &str,
        organization_id: Uuid,
    ) -> Result<bool, String>;
}

/// Registry of available tools with auto-discovery and DB registration
pub struct ToolsRegistry {
    tools: HashMap<String, Box<dyn McpTool>>,
    sensitive_tools: Vec<String>,
    registry_service: Option<crate::registry::McpToolRegistryService>,
}

impl ToolsRegistry {
    /// Create a new tools registry and auto-discover tools
    pub fn new() -> Self {
        let mut registry = Self {
            tools: HashMap::new(),
            sensitive_tools: Vec::new(),
            registry_service: None,
        };
        
        // Auto-discover and register tools marked with #[mcp_tool]
        registry.discover_tools();
        
        registry
    }

    /// Create with database registry service
    pub fn with_registry_service(
        registry_service: crate::registry::McpToolRegistryService,
    ) -> Self {
        let mut registry = Self {
            tools: HashMap::new(),
            sensitive_tools: Vec::new(),
            registry_service: Some(registry_service),
        };
        
        registry.discover_tools();
        
        registry
    }

    /// Discover tools automatically using build-time code generation
    fn discover_tools(&mut self) {
        // This will be populated by build.rs scanning for #[mcp_tool] attributes
        // For now, we'll manually register tools, but in production this would
        // be code-generated at build time
        
        // Example: Register tools from handlers
        // This would be auto-generated from proc macro scanning
    }

    /// Register a new tool (automatically stores in DB if registry_service is set)
    pub async fn register(
        &mut self,
        tool: Box<dyn McpTool>,
        organization_id: Uuid,
        registered_by: Option<Uuid>,
    ) -> McpResult<()> {
        // Store in memory
        if tool.is_sensitive() {
            self.sensitive_tools.push(tool.name().to_string());
        }
        self.tools.insert(tool.name().to_string(), tool);
        
        // Auto-register to database if registry service is available
        if let Some(ref registry_service) = self.registry_service {
            let tool_registry = crate::registry::McpToolRegistry {
                tool_name: tool.name().to_string(),
                handler_function: tool.handler_function().to_string(),
                handler_file: tool.handler_file().to_string(),
                description: tool.description().to_string(),
                category: tool.category().to_string(),
                response_type: tool.response_type_name().map(|s| s.to_string()),
                render_type: tool.render_type(),
                requires_permission: tool.required_permission().map(|s| s.to_string()),
                sensitive: tool.is_sensitive(),
                input_schema: Some(tool.input_schema()),
                output_schema: tool.output_schema(),
            };
            
            registry_service.register_tool(&tool_registry, organization_id, registered_by).await?;
        }
        
        Ok(())
    }

    /// List all available tools (excluding sensitive ones for public access)
    pub fn list(&self, include_sensitive: bool) -> Vec<Tool> {
        self.tools.values()
            .filter(|t| include_sensitive || !t.is_sensitive())
            .map(|t| Tool {
                name: t.name().to_string(),
                description: t.description().to_string(),
                input_schema: t.input_schema(),
                output_schema: t.output_schema(),
                render_type: t.render_type(),
            })
            .collect()
    }

    /// Execute a tool by name with auth and permission checks
    pub async fn execute(
        &self,
        input: ToolInput,
        auth_context: &AuthContext,
        zanzibar_client: Option<&dyn ZanzibarClient>,
    ) -> McpResult<ToolResult> {
        let tool = self.tools.get(&input.name)
            .ok_or_else(|| crate::error::McpError::Tool(
                format!("Tool '{}' not found", input.name)
            ))?;
        
        // Check if tool is sensitive
        if tool.is_sensitive() {
            return Err(crate::error::McpError::Permission(
                "Access to sensitive tools is restricted".to_string()
            ));
        }
        
        // Check Zanzibar permission if required
        if let Some(permission) = tool.required_permission() {
            if let Some(zanzibar) = zanzibar_client {
                let has_permission = zanzibar.check_permission(
                    auth_context.user_id,
                    tool.category(),
                    None, // Resource ID from input if available
                    permission,
                    auth_context.organization_id,
                ).await.map_err(|e| crate::error::McpError::Permission(e))?;
                
                if !has_permission {
                    return Err(crate::error::McpError::Permission(
                        format!("Permission '{}' required for tool '{}'", permission, tool.name())
                    ));
                }
            }
        }
        
        // Execute the tool
        tool.execute(input, auth_context, zanzibar_client).await
    }
}

impl Default for ToolsRegistry {
    fn default() -> Self {
        Self::new()
    }
}
