use crate::error::CryptoError;
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use zeroize::Zeroizing;

/// Result type for KMS operations
pub type KmsResult<T> = Result<T, CryptoError>;

/// Key metadata information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyMetadata {
    /// Unique key identifier
    pub key_id: String,
    /// Key alias (human-readable name)
    pub alias: Option<String>,
    /// Key creation timestamp
    pub created_at: DateTime<Utc>,
    /// Key state (enabled, disabled, pending_deletion, etc.)
    pub state: KeyState,
    /// Key usage (encrypt/decrypt, sign/verify)
    pub usage: KeyUsage,
    /// Key algorithm
    pub algorithm: String,
    /// Key origin (kms, external, custom_key_store)
    pub origin: KeyOrigin,
    /// Last rotation timestamp
    pub last_rotated: Option<DateTime<Utc>>,
    /// Next rotation timestamp (if automatic rotation enabled)
    pub next_rotation: Option<DateTime<Utc>>,
    /// Key description
    pub description: Option<String>,
    /// Custom tags
    pub tags: std::collections::HashMap<String, String>,
}

/// Key state
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum KeyState {
    /// Key is enabled and available for use
    Enabled,
    /// Key is disabled (can be re-enabled)
    Disabled,
    /// Key is pending deletion
    PendingDeletion,
    /// Key is pending import
    PendingImport,
    /// Key is unavailable
    Unavailable,
}

/// Key usage type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum KeyUsage {
    /// Encrypt and decrypt operations
    EncryptDecrypt,
    /// Sign and verify operations
    SignVerify,
}

/// Key origin
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum KeyOrigin {
    /// Key generated by KMS
    Kms,
    /// Key imported from external source
    External,
    /// Key from CloudHSM custom key store
    CustomKeyStore,
}

/// Key rotation policy
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyRotationPolicy {
    /// Enable automatic rotation
    pub enabled: bool,
    /// Rotation period in days (e.g., 365 for yearly)
    pub rotation_period_days: Option<u32>,
    /// Last rotation timestamp
    pub last_rotated: Option<DateTime<Utc>>,
    /// Next scheduled rotation
    pub next_rotation: Option<DateTime<Utc>>,
}

/// Key Management Service trait
/// 
/// Provides abstraction for enterprise key management systems like
/// AWS KMS, HashiCorp Vault, Azure Key Vault, Google Cloud KMS, etc.
#[async_trait]
pub trait KeyManagementService: Send + Sync {
    /// Generate a new Data Encryption Key (DEK)
    /// 
    /// Returns a plaintext DEK and its encrypted version (wrapped with KEK).
    /// The plaintext should be used immediately and then zeroized.
    /// The encrypted DEK should be stored alongside the encrypted data.
    /// 
    /// # Arguments
    /// * `kek_id` - Key Encryption Key identifier
    /// * `key_spec` - Key specification (e.g., "AES_256")
    /// * `context` - Optional encryption context for additional security
    /// 
    /// # Returns
    /// Tuple of (plaintext_dek, encrypted_dek)
    async fn generate_data_key(
        &self,
        kek_id: &str,
        key_spec: &str,
        context: Option<&std::collections::HashMap<String, String>>,
    ) -> KmsResult<(Zeroizing<Vec<u8>>, Vec<u8>)>;

    /// Decrypt an encrypted Data Encryption Key
    /// 
    /// # Arguments
    /// * `encrypted_dek` - The encrypted DEK to decrypt
    /// * `context` - Optional encryption context (must match the one used during encryption)
    /// 
    /// # Returns
    /// Plaintext DEK (automatically zeroized when dropped)
    async fn decrypt_data_key(
        &self,
        encrypted_dek: &[u8],
        context: Option<&std::collections::HashMap<String, String>>,
    ) -> KmsResult<Zeroizing<Vec<u8>>>;

    /// Encrypt data directly using KMS (for small data < 4KB)
    /// 
    /// Note: For large data, use generate_data_key + local encryption instead.
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier
    /// * `plaintext` - Data to encrypt (max 4KB for most KMS providers)
    /// * `context` - Optional encryption context
    async fn encrypt(
        &self,
        key_id: &str,
        plaintext: &[u8],
        context: Option<&std::collections::HashMap<String, String>>,
    ) -> KmsResult<Vec<u8>>;

    /// Decrypt data encrypted with KMS
    /// 
    /// # Arguments
    /// * `ciphertext` - Encrypted data
    /// * `context` - Optional encryption context (must match encryption)
    async fn decrypt(
        &self,
        ciphertext: &[u8],
        context: Option<&std::collections::HashMap<String, String>>,
    ) -> KmsResult<Zeroizing<Vec<u8>>>;

    /// Re-encrypt data under a new key (without exposing plaintext)
    /// 
    /// This is useful for key rotation. The KMS performs the re-encryption
    /// internally without exposing the plaintext to the application.
    /// 
    /// # Arguments
    /// * `ciphertext` - Data encrypted with old key
    /// * `new_key_id` - New key identifier
    /// * `source_context` - Encryption context used for original encryption
    /// * `dest_context` - Encryption context for new encryption
    async fn re_encrypt(
        &self,
        ciphertext: &[u8],
        new_key_id: &str,
        source_context: Option<&std::collections::HashMap<String, String>>,
        dest_context: Option<&std::collections::HashMap<String, String>>,
    ) -> KmsResult<Vec<u8>>;

    /// Create a new Key Encryption Key (KEK)
    /// 
    /// # Arguments
    /// * `description` - Key description
    /// * `key_spec` - Key specification (e.g., "SYMMETRIC_DEFAULT")
    /// * `key_usage` - Key usage type
    /// * `tags` - Optional tags for the key
    async fn create_key(
        &self,
        description: &str,
        key_spec: &str,
        key_usage: KeyUsage,
        tags: Option<std::collections::HashMap<String, String>>,
    ) -> KmsResult<KeyMetadata>;

    /// Get key metadata
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier or alias
    async fn describe_key(&self, key_id: &str) -> KmsResult<KeyMetadata>;

    /// List all keys (with optional filtering)
    /// 
    /// # Arguments
    /// * `max_results` - Maximum number of results to return
    async fn list_keys(&self, max_results: Option<u32>) -> KmsResult<Vec<KeyMetadata>>;

    /// Enable automatic key rotation
    /// 
    /// When enabled, the KMS will automatically rotate the key material
    /// according to the rotation policy. Old key material is retained for
    /// decryption of existing data.
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier
    /// * `rotation_period_days` - Rotation period (e.g., 365 for yearly)
    async fn enable_key_rotation(
        &self,
        key_id: &str,
        rotation_period_days: Option<u32>,
    ) -> KmsResult<()>;

    /// Disable automatic key rotation
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier
    async fn disable_key_rotation(&self, key_id: &str) -> KmsResult<()>;

    /// Get key rotation status
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier
    async fn get_key_rotation_status(&self, key_id: &str) -> KmsResult<KeyRotationPolicy>;

    /// Manually rotate a key
    /// 
    /// Creates a new version of the key material while retaining old versions
    /// for decryption. Unlike automatic rotation, this gives you control over
    /// when rotation occurs.
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier
    async fn rotate_key(&self, key_id: &str) -> KmsResult<KeyMetadata>;

    /// Enable a key
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier
    async fn enable_key(&self, key_id: &str) -> KmsResult<()>;

    /// Disable a key
    /// 
    /// Disabled keys cannot be used for cryptographic operations but can
    /// be re-enabled. Use this instead of deletion for temporary disablement.
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier
    async fn disable_key(&self, key_id: &str) -> KmsResult<()>;

    /// Schedule key deletion
    /// 
    /// Keys are not deleted immediately but enter a waiting period (7-30 days)
    /// during which the deletion can be cancelled. This prevents accidental
    /// data loss.
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier
    /// * `pending_window_days` - Waiting period before deletion (7-30 days)
    async fn schedule_key_deletion(
        &self,
        key_id: &str,
        pending_window_days: u32,
    ) -> KmsResult<DateTime<Utc>>;

    /// Cancel scheduled key deletion
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier
    async fn cancel_key_deletion(&self, key_id: &str) -> KmsResult<()>;

    /// Create an alias for a key
    /// 
    /// Aliases provide human-readable names for keys. They can be updated
    /// to point to different keys, enabling seamless key rotation.
    /// 
    /// # Arguments
    /// * `alias_name` - Alias name (must be unique)
    /// * `key_id` - Key identifier to associate with alias
    async fn create_alias(&self, alias_name: &str, key_id: &str) -> KmsResult<()>;

    /// Update an alias to point to a different key
    /// 
    /// # Arguments
    /// * `alias_name` - Alias name
    /// * `key_id` - New key identifier
    async fn update_alias(&self, alias_name: &str, key_id: &str) -> KmsResult<()>;

    /// Delete an alias
    /// 
    /// # Arguments
    /// * `alias_name` - Alias name to delete
    async fn delete_alias(&self, alias_name: &str) -> KmsResult<()>;

    /// List aliases for a key
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier
    async fn list_aliases(&self, key_id: &str) -> KmsResult<Vec<String>>;

    /// Get audit logs for key usage
    /// 
    /// Returns cryptographic operations performed with the key for compliance
    /// and security monitoring.
    /// 
    /// # Arguments
    /// * `key_id` - Key identifier
    /// * `start_time` - Start of time range
    /// * `end_time` - End of time range
    async fn get_key_audit_logs(
        &self,
        key_id: &str,
        start_time: DateTime<Utc>,
        end_time: DateTime<Utc>,
    ) -> KmsResult<Vec<AuditLogEntry>>;
}

/// Audit log entry for key operations
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditLogEntry {
    /// Timestamp of operation
    pub timestamp: DateTime<Utc>,
    /// Operation type (encrypt, decrypt, generate_data_key, etc.)
    pub operation: String,
    /// Key identifier used
    pub key_id: String,
    /// Principal (user/role) who performed operation
    pub principal: String,
    /// Source IP address
    pub source_ip: Option<String>,
    /// Request ID for tracing
    pub request_id: String,
    /// Operation result (success/failure)
    pub status: OperationStatus,
    /// Error message (if failed)
    pub error_message: Option<String>,
}

/// Operation status
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum OperationStatus {
    Success,
    Failure,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_key_state_serialization() {
        let state = KeyState::Enabled;
        let json = serde_json::to_string(&state).unwrap();
        assert_eq!(json, "\"Enabled\"");

        let deserialized: KeyState = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized, state);
    }

    #[test]
    fn test_key_usage_serialization() {
        let usage = KeyUsage::EncryptDecrypt;
        let json = serde_json::to_string(&usage).unwrap();
        let deserialized: KeyUsage = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized, usage);
    }

    #[test]
    fn test_key_metadata_creation() {
        let metadata = KeyMetadata {
            key_id: "key-123".to_string(),
            alias: Some("alias/my-key".to_string()),
            created_at: Utc::now(),
            state: KeyState::Enabled,
            usage: KeyUsage::EncryptDecrypt,
            algorithm: "AES_256".to_string(),
            origin: KeyOrigin::Kms,
            last_rotated: None,
            next_rotation: None,
            description: Some("Test key".to_string()),
            tags: std::collections::HashMap::new(),
        };

        assert_eq!(metadata.key_id, "key-123");
        assert_eq!(metadata.state, KeyState::Enabled);
    }
}
