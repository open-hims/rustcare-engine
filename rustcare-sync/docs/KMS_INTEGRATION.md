# KMS Integration for Local Database Keys

## Overview

Phase LS3 implements **Key Management Service (KMS) integration** for managing SQLite encryption keys in RustCare's offline-first architecture. Instead of deriving encryption keys from passwords using PBKDF2, this approach leverages enterprise-grade KMS providers (AWS KMS, HashiCorp Vault) for enhanced security and key lifecycle management.

## Architecture

### Key Hierarchy

```
┌─────────────────────────────────────┐
│     KMS Provider (AWS/Vault)        │
│   ┌─────────────────────────────┐   │
│   │  KEK (Key Encryption Key)   │   │ ← Never leaves KMS
│   │  - Hardware-backed          │   │
│   │  - Policy-controlled        │   │
│   └─────────────────────────────┘   │
└────────────────┬────────────────────┘
                 │
                 │ generate_data_key()
                 │ decrypt_data_key()
                 │
                 ▼
┌─────────────────────────────────────┐
│     LocalDbKeyManager              │
│   ┌─────────────────────────────┐   │
│   │  DEK (Data Encryption Key)  │   │ ← Encrypted locally
│   │  - 256-bit AES key          │   │
│   │  - Encrypted by KEK         │   │
│   │  - Stored in .key file      │   │
│   └─────────────────────────────┘   │
└────────────────┬────────────────────┘
                 │
                 │ encrypt/decrypt
                 │
                 ▼
┌─────────────────────────────────────┐
│     SQLite Database (SQLCipher)     │
│   - Encrypted with DEK              │
│   - AES-256 encryption              │
│   - HIPAA-compliant                 │
└─────────────────────────────────────┘
```

### Components

1. **KEK (Key Encryption Key)**
   - Stored in KMS (never leaves hardware)
   - Managed by enterprise KMS provider
   - Access controlled by IAM policies
   - Supports key rotation, audit logs

2. **DEK (Data Encryption Key)**
   - Generated by KMS via `generate_data_key()`
   - 256-bit AES key for database encryption
   - Encrypted by KEK before local storage
   - Stored in `.key` metadata file (Unix 600 permissions)

3. **LocalDbKeyManager**
   - Manages DEK lifecycle (generate, load, rotate)
   - Interfaces with KMS via `KeyManagementService` trait
   - Handles metadata persistence
   - Implements zeroizing for security

## Usage

### Configuration

Add KMS configuration to `LocalDbConfig`:

```rust
use rustcare_sync::{LocalDbConfig, KeyManagerConfig};

let config = LocalDbConfig {
    db_path: "medical_records.db".to_string(),
    // ... other settings ...
    kms_config: Some(KeyManagerConfig {
        kms_type: "aws".to_string(),
        kek_id: "arn:aws:kms:us-east-1:123456789012:key/abc123".to_string(),
        encryption_context: [
            ("purpose".to_string(), "medical-db".to_string()),
            ("environment".to_string(), "production".to_string()),
        ].into_iter().collect(),
        dek_spec: "AES_256".to_string(),
        rotation_enabled: true,
        rotation_period_days: 90,
    }),
};

let db = LocalDatabase::new(config).await?;
```

### Key Generation (New Database)

```rust
use rustcare_sync::LocalDbKeyManager;
use std::path::PathBuf;
use std::sync::Arc;

// Initialize KMS provider (AWS KMS example)
let kms: Arc<dyn KeyManagementService> = Arc::new(
    AwsKmsProvider::new(aws_config).await?
);

// Create key manager
let key_manager = LocalDbKeyManager::new(kms, config, PathBuf::from("medical_records.db"));

// Generate new key (creates DEK via KMS, saves encrypted metadata)
let database_key = key_manager.initialize().await?;

// Use database_key with SQLCipher...
```

### Key Loading (Existing Database)

```rust
// Load existing key (decrypts DEK from metadata file)
let database_key = key_manager.load().await?;

// Or use convenience method (auto-detects new vs. existing)
let database_key = key_manager.get_or_create_key().await?;
```

### Key Rotation

```rust
// Check if rotation is needed (based on rotation_period_days)
if key_manager.needs_rotation().await? {
    // Generate new DEK, update metadata
    let new_key = key_manager.rotate_key().await?;
    
    // TODO: Re-encrypt database with new key
    // (requires SQLCipher re-keying, planned for future)
}
```

## Metadata Format

Encryption metadata is stored in a separate file alongside the database:

**File**: `{database_path}.key`  
**Permissions**: Unix 600 (read/write owner only)

```json
{
  "encrypted_dek": "AQICAHh...base64...",
  "kek_id": "arn:aws:kms:us-east-1:123456789012:key/abc123",
  "version": 1,
  "created_at": "2024-01-15T10:30:00Z",
  "rotated_at": null,
  "encryption_context": {
    "purpose": "medical-db",
    "environment": "production"
  },
  "dek_spec": "AES_256"
}
```

## Security Features

### 1. Hardware-Backed Keys
- KEK stored in FIPS 140-2 Level 2+ HSMs (via KMS)
- DEK generated by KMS, not client
- Cryptographically random key generation

### 2. Access Control
- IAM policies control KMS access
- Encryption context binds keys to specific use cases
- Prevents unauthorized key usage

### 3. Audit Trail
- All KMS operations logged (CloudTrail for AWS)
- Key usage tracking
- Compliance reporting

### 4. Key Rotation
- Automated key rotation policies
- Version tracking in metadata
- Seamless transition (planned)

### 5. Defense in Depth
- Multiple encryption layers (KMS → DEK → Database)
- Zeroizing for sensitive data in memory
- Unix file permissions on metadata

## KMS Provider Support

### AWS KMS
```rust
use crypto::kms::aws::AwsKmsProvider;

let kms = Arc::new(AwsKmsProvider::new(aws_config).await?);
```

**Required IAM Permissions**:
- `kms:GenerateDataKey`
- `kms:Decrypt`
- `kms:DescribeKey`
- `kms:GetPublicKey` (optional)

### HashiCorp Vault
```rust
use crypto::kms::vault::VaultKmsProvider;

let kms = Arc::new(VaultKmsProvider::new(vault_config).await?);
```

**Required Vault Policies**:
- `transit/datakey/plaintext/{key_name}`
- `transit/decrypt/{key_name}`

### Mock KMS (Testing)
```rust
use rustcare_sync::key_manager::MockKms;

let kms = Arc::new(MockKms::new());
// Simulates KMS operations without real infrastructure
```

## Implementation Details

### Module Structure

**File**: `rustcare-sync/src/key_manager.rs` (580 lines)

Key components:
- `KeyManagerConfig` - Configuration struct
- `LocalDbKeyMetadata` - Metadata persistence format
- `LocalDbKeyManager` - Main key management interface
- `MockKms` - Test infrastructure

### Methods

```rust
impl LocalDbKeyManager {
    /// Generate a new DEK via KMS
    async fn generate_key(&self) -> Result<DatabaseKey>;
    
    /// Load existing DEK from metadata
    async fn load_key(&self) -> Result<DatabaseKey>;
    
    /// Save metadata to disk (Unix 600)
    async fn save_metadata(&self, metadata: &LocalDbKeyMetadata) -> Result<()>;
    
    /// Load metadata from disk
    async fn load_metadata(&self) -> Result<LocalDbKeyMetadata>;
    
    /// Initialize new database (generate key + save metadata)
    pub async fn initialize(&self) -> Result<DatabaseKey>;
    
    /// Load existing database key
    pub async fn load(&self) -> Result<DatabaseKey>;
    
    /// Auto-detect new vs. existing database
    pub async fn get_or_create_key(&self) -> Result<DatabaseKey>;
    
    /// Rotate key (generate new DEK, update metadata)
    pub async fn rotate_key(&self) -> Result<DatabaseKey>;
    
    /// Check if rotation is needed
    pub async fn needs_rotation(&self) -> Result<bool>;
}
```

## Testing

All 5 tests pass:

1. **test_generate_key** - Verify DEK generation via MockKms
2. **test_save_and_load_metadata** - Metadata persistence
3. **test_initialize_and_load** - New database flow
4. **test_get_or_create_key_creates_new** - Auto-create for new DB
5. **test_get_or_create_key_loads_existing** - Auto-load for existing DB

Run tests:
```bash
cargo test --lib key_manager
```

## Compliance Benefits

### HIPAA
- ✅ **§164.312(a)(2)(iv)** - Encryption and decryption (hardware-backed)
- ✅ **§164.312(e)(2)(ii)** - Encryption (AES-256 via KMS)
- ✅ **§164.312(c)(1)** - Integrity controls (encryption context)
- ✅ **§164.308(a)(1)(ii)(D)** - Risk management (enterprise KMS)

### GDPR
- ✅ **Article 32** - Security of processing (state-of-the-art encryption)
- ✅ **Article 25** - Data protection by design (defense in depth)

### SOC 2
- ✅ **CC6.1** - Logical and physical access controls (IAM + HSM)
- ✅ **CC6.6** - Encryption (KMS-backed)
- ✅ **CC6.7** - Audit logging (CloudTrail integration)

## Migration Path

For existing databases using password-based keys:

1. **Generate KMS-backed key**:
   ```rust
   let new_key = key_manager.initialize().await?;
   ```

2. **SQLCipher re-keying** (requires future implementation):
   ```sql
   PRAGMA key = 'old_password_derived_key';
   PRAGMA rekey = 'new_kms_backed_key';
   ```

3. **Update configuration**:
   ```rust
   config.kms_config = Some(kms_config);
   ```

## Performance Considerations

- **Key Generation**: ~200ms (KMS network call)
- **Key Loading**: ~100ms (KMS decrypt call)
- **Caching**: Consider caching decrypted DEK in memory (with zeroizing)
- **Batch Operations**: KMS API supports batch operations for scale

## Future Enhancements

1. **DEK Caching** - Cache decrypted DEK in memory with TTL
2. **Re-encryption** - Implement SQLCipher re-keying for rotation
3. **Multi-Region** - Support multi-region KMS replication
4. **Key Versioning** - Track all historical key versions
5. **Emergency Access** - Break-glass procedures for key recovery
6. **Key Derivation** - Derive multiple keys from single master DEK

## References

- [AWS KMS Best Practices](https://docs.aws.amazon.com/kms/latest/developerguide/best-practices.html)
- [HashiCorp Vault Transit Engine](https://www.vaultproject.io/docs/secrets/transit)
- [NIST SP 800-57 Key Management](https://csrc.nist.gov/publications/detail/sp/800-57-part-1/rev-5/final)
- [SQLCipher Key Derivation](https://www.zetetic.net/sqlcipher/sqlcipher-api/#key)

## License

Copyright © 2024 RustCare. All rights reserved.
