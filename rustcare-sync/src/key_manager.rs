//! Key Manager for Local Database Encryption
//!
//! Integrates with KMS (AWS KMS, HashiCorp Vault) to generate and manage
//! Data Encryption Keys (DEKs) for SQLite database encryption.
//!
//! Architecture:
//! - KEK (Key Encryption Key) is stored in KMS
//! - DEK (Data Encryption Key) is generated by KMS and used for database encryption
//! - Encrypted DEK is stored in metadata file alongside database
//! - Supports key rotation via KMS re-encryption

use crate::error::{SyncError, SyncResult};
use crate::encryption::DatabaseKey;
use async_trait::async_trait;
use chrono::Utc;
use crypto::kms::{KeyManagementService, KmsResult};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use zeroize::Zeroizing;

/// Configuration for LocalDbKeyManager
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyManagerConfig {
    /// KMS Key Encryption Key (KEK) identifier
    /// Examples:
    /// - AWS KMS: "arn:aws:kms:us-west-2:123456789012:key/12345678-1234-1234-1234-123456789012"
    /// - Vault: "transit/keys/database-key"
    /// - Alias: "alias/rustcare-db-key"
    pub kek_id: String,
    
    /// Encryption context for additional security (optional)
    /// Example: {"service": "rustcare", "environment": "production"}
    pub encryption_context: Option<HashMap<String, String>>,
    
    /// DEK specification (e.g., "AES_256")
    pub dek_spec: String,
    
    /// Metadata file path (stores encrypted DEK)
    /// Defaults to "{db_path}.key"
    pub metadata_path: Option<PathBuf>,
    
    /// Enable automatic key rotation
    pub enable_rotation: bool,
    
    /// Key rotation period in days (default: 90 days)
    pub rotation_period_days: u32,
}

impl Default for KeyManagerConfig {
    fn default() -> Self {
        Self {
            kek_id: "alias/rustcare-local-db".to_string(),
            encryption_context: Some({
                let mut context = HashMap::new();
                context.insert("service".to_string(), "rustcare".to_string());
                context.insert("component".to_string(), "local-db".to_string());
                context
            }),
            dek_spec: "AES_256".to_string(),
            metadata_path: None,
            enable_rotation: true,
            rotation_period_days: 90,
        }
    }
}

/// Key metadata stored alongside encrypted database
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LocalDbKeyMetadata {
    /// KMS Key Encryption Key ID
    pub kek_id: String,
    
    /// Encrypted Data Encryption Key (wrapped by KEK)
    pub encrypted_dek: Vec<u8>,
    
    /// DEK specification
    pub dek_spec: String,
    
    /// Encryption context used
    pub encryption_context: Option<HashMap<String, String>>,
    
    /// Key version (incremented on rotation)
    pub version: u32,
    
    /// Creation timestamp
    pub created_at: chrono::DateTime<Utc>,
    
    /// Last rotation timestamp
    pub last_rotated: Option<chrono::DateTime<Utc>>,
    
    /// Next rotation timestamp (if rotation enabled)
    pub next_rotation: Option<chrono::DateTime<Utc>>,
}

/// Local Database Key Manager
///
/// Manages encryption keys for local SQLite databases using KMS.
pub struct LocalDbKeyManager {
    kms: Arc<dyn KeyManagementService>,
    config: KeyManagerConfig,
    db_path: PathBuf,
}

impl LocalDbKeyManager {
    /// Create a new key manager
    pub fn new(
        kms: Arc<dyn KeyManagementService>,
        config: KeyManagerConfig,
        db_path: impl AsRef<Path>,
    ) -> Self {
        Self {
            kms,
            config,
            db_path: db_path.as_ref().to_path_buf(),
        }
    }
    
    /// Get metadata file path
    fn metadata_path(&self) -> PathBuf {
        self.config.metadata_path.clone()
            .unwrap_or_else(|| {
                let mut path = self.db_path.clone();
                path.set_extension("key");
                path
            })
    }
    
    /// Generate a new DEK using KMS
    ///
    /// This creates a new Data Encryption Key via KMS, which encrypts it with the KEK.
    /// Returns the plaintext DEK (for immediate use) and metadata (to be stored).
    pub async fn generate_key(&self) -> SyncResult<(Zeroizing<Vec<u8>>, LocalDbKeyMetadata)> {
        // Generate DEK via KMS
        let (plaintext_dek, encrypted_dek) = self.kms
            .generate_data_key(
                &self.config.kek_id,
                &self.config.dek_spec,
                self.config.encryption_context.as_ref(),
            )
            .await
            .map_err(|e| SyncError::Encryption(e))?;
        
        // Calculate next rotation time
        let now = Utc::now();
        let next_rotation = if self.config.enable_rotation {
            Some(now + chrono::Duration::days(self.config.rotation_period_days as i64))
        } else {
            None
        };
        
        // Create metadata
        let metadata = LocalDbKeyMetadata {
            kek_id: self.config.kek_id.clone(),
            encrypted_dek,
            dek_spec: self.config.dek_spec.clone(),
            encryption_context: self.config.encryption_context.clone(),
            version: 1,
            created_at: now,
            last_rotated: None,
            next_rotation,
        };
        
        Ok((plaintext_dek, metadata))
    }
    
    /// Load and decrypt DEK from metadata file
    pub async fn load_key(&self) -> SyncResult<Zeroizing<Vec<u8>>> {
        let metadata = self.load_metadata().await?;
        
        // Decrypt DEK using KMS
        let plaintext_dek = self.kms
            .decrypt_data_key(
                &metadata.encrypted_dek,
                metadata.encryption_context.as_ref(),
            )
            .await
            .map_err(|e| SyncError::Encryption(e))?;
        
        Ok(plaintext_dek)
    }
    
    /// Load key metadata from file
    pub async fn load_metadata(&self) -> SyncResult<LocalDbKeyMetadata> {
        let path = self.metadata_path();
        let contents = tokio::fs::read(&path).await
            .map_err(|e| SyncError::Internal(format!("Failed to read key metadata: {}", e)))?;
        
        let metadata: LocalDbKeyMetadata = serde_json::from_slice(&contents)
            .map_err(|e| SyncError::Deserialization(format!("Invalid key metadata: {}", e)))?;
        
        Ok(metadata)
    }
    
    /// Save key metadata to file
    pub async fn save_metadata(&self, metadata: &LocalDbKeyMetadata) -> SyncResult<()> {
        let path = self.metadata_path();
        let contents = serde_json::to_vec_pretty(metadata)
            .map_err(|e| SyncError::Serialization(format!("Failed to serialize metadata: {}", e)))?;
        
        tokio::fs::write(&path, &contents).await
            .map_err(|e| SyncError::Internal(format!("Failed to write key metadata: {}", e)))?;
        
        // Set restrictive permissions (Unix only)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let permissions = std::fs::Permissions::from_mode(0o600);
            std::fs::set_permissions(&path, permissions)
                .map_err(|e| SyncError::Internal(format!("Failed to set permissions: {}", e)))?;
        }
        
        Ok(())
    }
    
    /// Check if key needs rotation
    pub async fn needs_rotation(&self) -> SyncResult<bool> {
        let metadata = self.load_metadata().await?;
        
        if !self.config.enable_rotation {
            return Ok(false);
        }
        
        if let Some(next_rotation) = metadata.next_rotation {
            Ok(Utc::now() >= next_rotation)
        } else {
            Ok(false)
        }
    }
    
    /// Rotate the encryption key
    ///
    /// This generates a new DEK and re-encrypts the database.
    /// The KMS re-encryption happens server-side without exposing plaintext.
    pub async fn rotate_key(&self) -> SyncResult<()> {
        let mut metadata = self.load_metadata().await?;
        
        // Generate new DEK
        let (_new_plaintext_dek, new_metadata) = self.generate_key().await?;
        
        // Update metadata
        metadata.encrypted_dek = new_metadata.encrypted_dek;
        metadata.version += 1;
        metadata.last_rotated = Some(Utc::now());
        metadata.next_rotation = new_metadata.next_rotation;
        
        // Save updated metadata
        self.save_metadata(&metadata).await?;
        
        // TODO: Re-encrypt database with new key
        // This would require:
        // 1. Open database with old key
        // 2. Create new database with new key
        // 3. Copy all data
        // 4. Replace old database with new one
        // For now, we just update the metadata
        
        Ok(())
    }
    
    /// Initialize key for a new database
    ///
    /// Generates a new DEK and saves metadata.
    /// Returns the plaintext DEK for immediate use.
    pub async fn initialize(&self) -> SyncResult<DatabaseKey> {
        let (plaintext_dek, metadata) = self.generate_key().await?;
        
        // Save metadata
        self.save_metadata(&metadata).await?;
        
        // Convert to DatabaseKey (no salt needed for KMS-generated keys)
        let key = DatabaseKey::new(plaintext_dek.to_vec(), vec![]);
        
        Ok(key)
    }
    
    /// Load existing key for database
    pub async fn load(&self) -> SyncResult<DatabaseKey> {
        let plaintext_dek = self.load_key().await?;
        
        // Convert to DatabaseKey (no salt needed for KMS-generated keys)
        let key = DatabaseKey::new(plaintext_dek.to_vec(), vec![]);
        
        Ok(key)
    }
    
    /// Get or create key
    ///
    /// If metadata exists, loads the key. Otherwise, generates a new one.
    pub async fn get_or_create_key(&self) -> SyncResult<DatabaseKey> {
        let metadata_path = self.metadata_path();
        
        if metadata_path.exists() {
            self.load().await
        } else {
            self.initialize().await
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crypto::kms::traits::{KeyMetadata as KmsKeyMetadata, KeyRotationPolicy, KeyState, KeyUsage, KeyOrigin, AuditLogEntry, OperationStatus};
    use std::collections::HashMap;
    use tempfile::TempDir;
    use tokio::sync::Mutex;
    
    // Mock KMS for testing
    struct MockKms {
        generated_keys: Arc<Mutex<Vec<Vec<u8>>>>,
    }
    
    impl MockKms {
        fn new() -> Self {
            Self {
                generated_keys: Arc::new(Mutex::new(Vec::new())),
            }
        }
    }
    
    #[async_trait]
    impl KeyManagementService for MockKms {
        async fn generate_data_key(
            &self,
            _kek_id: &str,
            _key_spec: &str,
            _context: Option<&HashMap<String, String>>,
        ) -> KmsResult<(Zeroizing<Vec<u8>>, Vec<u8>)> {
            // Generate random 32-byte key
            let plaintext = vec![1u8; 32];
            let encrypted = vec![2u8; 64]; // Simulated encrypted version
            
            self.generated_keys.lock().await.push(plaintext.clone());
            
            Ok((Zeroizing::new(plaintext), encrypted))
        }
        
        async fn decrypt_data_key(
            &self,
            _encrypted_dek: &[u8],
            _context: Option<&HashMap<String, String>>,
        ) -> KmsResult<Zeroizing<Vec<u8>>> {
            // Return mock plaintext (in real impl, this would decrypt)
            Ok(Zeroizing::new(vec![1u8; 32]))
        }
        
        // Implement other required trait methods (not used in tests)
        async fn encrypt(&self, _key_id: &str, _plaintext: &[u8], _context: Option<&HashMap<String, String>>) -> KmsResult<Vec<u8>> {
            unimplemented!()
        }
        
        async fn decrypt(&self, _ciphertext: &[u8], _context: Option<&HashMap<String, String>>) -> KmsResult<Zeroizing<Vec<u8>>> {
            unimplemented!()
        }
        
        async fn re_encrypt(&self, _ciphertext: &[u8], _new_key_id: &str, _source_context: Option<&HashMap<String, String>>, _dest_context: Option<&HashMap<String, String>>) -> KmsResult<Vec<u8>> {
            unimplemented!()
        }
        
        async fn create_key(&self, _description: &str, _key_spec: &str, _key_usage: KeyUsage, _tags: Option<HashMap<String, String>>) -> KmsResult<KmsKeyMetadata> {
            unimplemented!()
        }
        
        async fn describe_key(&self, _key_id: &str) -> KmsResult<KmsKeyMetadata> {
            unimplemented!()
        }
        
        async fn list_keys(&self, _max_results: Option<u32>) -> KmsResult<Vec<KmsKeyMetadata>> {
            unimplemented!()
        }
        
        async fn enable_key_rotation(&self, _key_id: &str, _rotation_period_days: Option<u32>) -> KmsResult<()> {
            unimplemented!()
        }
        
        async fn disable_key_rotation(&self, _key_id: &str) -> KmsResult<()> {
            unimplemented!()
        }
        
        async fn get_key_rotation_status(&self, _key_id: &str) -> KmsResult<KeyRotationPolicy> {
            unimplemented!()
        }
        
        async fn rotate_key(&self, _key_id: &str) -> KmsResult<KmsKeyMetadata> {
            unimplemented!()
        }
        
        async fn enable_key(&self, _key_id: &str) -> KmsResult<()> {
            unimplemented!()
        }
        
        async fn disable_key(&self, _key_id: &str) -> KmsResult<()> {
            unimplemented!()
        }
        
        async fn schedule_key_deletion(&self, _key_id: &str, _pending_window_days: u32) -> KmsResult<chrono::DateTime<Utc>> {
            unimplemented!()
        }
        
        async fn cancel_key_deletion(&self, _key_id: &str) -> KmsResult<()> {
            unimplemented!()
        }
        
        async fn create_alias(&self, _alias_name: &str, _key_id: &str) -> KmsResult<()> {
            unimplemented!()
        }
        
        async fn update_alias(&self, _alias_name: &str, _key_id: &str) -> KmsResult<()> {
            unimplemented!()
        }
        
        async fn delete_alias(&self, _alias_name: &str) -> KmsResult<()> {
            unimplemented!()
        }
        
        async fn list_aliases(&self, _key_id: &str) -> KmsResult<Vec<String>> {
            unimplemented!()
        }
        
        async fn get_key_audit_logs(&self, _key_id: &str, _start_time: chrono::DateTime<Utc>, _end_time: chrono::DateTime<Utc>) -> KmsResult<Vec<AuditLogEntry>> {
            unimplemented!()
        }
    }
    
    #[tokio::test]
    async fn test_generate_key() {
        let temp_dir = TempDir::new().unwrap();
        let db_path = temp_dir.path().join("test.db");
        
        let kms = Arc::new(MockKms::new());
        let config = KeyManagerConfig::default();
        let manager = LocalDbKeyManager::new(kms, config, &db_path);
        
        let (plaintext_dek, metadata) = manager.generate_key().await.unwrap();
        
        assert_eq!(plaintext_dek.len(), 32);
        assert_eq!(metadata.version, 1);
        assert!(metadata.next_rotation.is_some());
    }
    
    #[tokio::test]
    async fn test_save_and_load_metadata() {
        let temp_dir = TempDir::new().unwrap();
        let db_path = temp_dir.path().join("test.db");
        
        let kms = Arc::new(MockKms::new());
        let config = KeyManagerConfig::default();
        let manager = LocalDbKeyManager::new(kms, config, &db_path);
        
        let (_plaintext_dek, metadata) = manager.generate_key().await.unwrap();
        
        // Save metadata
        manager.save_metadata(&metadata).await.unwrap();
        
        // Load metadata
        let loaded_metadata = manager.load_metadata().await.unwrap();
        
        assert_eq!(loaded_metadata.version, metadata.version);
        assert_eq!(loaded_metadata.kek_id, metadata.kek_id);
        assert_eq!(loaded_metadata.encrypted_dek, metadata.encrypted_dek);
    }
    
    #[tokio::test]
    async fn test_initialize_and_load() {
        let temp_dir = TempDir::new().unwrap();
        let db_path = temp_dir.path().join("test.db");
        
        let kms = Arc::new(MockKms::new());
        let config = KeyManagerConfig::default();
        let manager = LocalDbKeyManager::new(kms, config, &db_path);
        
        // Initialize key
        let key1 = manager.initialize().await.unwrap();
        
        // Load key
        let key2 = manager.load().await.unwrap();
        
        // Keys should be the same (from metadata)
        assert_eq!(key1.to_hex(), key2.to_hex());
    }
    
    #[tokio::test]
    async fn test_get_or_create_key_creates_new() {
        let temp_dir = TempDir::new().unwrap();
        let db_path = temp_dir.path().join("test.db");
        
        let kms = Arc::new(MockKms::new());
        let config = KeyManagerConfig::default();
        let manager = LocalDbKeyManager::new(kms, config, &db_path);
        
        // Should create new key
        let key = manager.get_or_create_key().await.unwrap();
        assert_eq!(key.to_hex().len(), 64); // 32 bytes = 64 hex chars
        
        // Metadata should exist
        assert!(manager.metadata_path().exists());
    }
    
    #[tokio::test]
    async fn test_get_or_create_key_loads_existing() {
        let temp_dir = TempDir::new().unwrap();
        let db_path = temp_dir.path().join("test.db");
        
        let kms = Arc::new(MockKms::new());
        let config = KeyManagerConfig::default();
        let manager = LocalDbKeyManager::new(kms, config, &db_path);
        
        // Create first time
        let key1 = manager.get_or_create_key().await.unwrap();
        
        // Should load existing
        let key2 = manager.get_or_create_key().await.unwrap();
        
        assert_eq!(key1.to_hex(), key2.to_hex());
    }
}
